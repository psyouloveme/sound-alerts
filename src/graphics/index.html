<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Sound Alerts</title>
    <style>
      body {
        background-color: rgba(0, 0, 0, 0);
        display: none;
      }
    </style>
  </head>

  <body>
    <script>
      const audioEnabled = nodecg.Replicant("audio_alerts_enabled", {
        defaultValue: false,
      });

      const cmds = {
        "countz4MiuRainbow" : [ 
          "!sure",
          "!ding",
          "!go"
        ]
      }

      const mod = (n, d) => ((n % d) + d) % d

      const hashStr = (str) => {
        var hash = 0,
          i, chr;
        if (str.length === 0) return hash;
        for (i = 0; i < str.length; i++) {
          chr = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + chr;
          hash |= 0; // Convert to 32bit integer
        }
        return hash;
      }

      const onChatReceived = ({ user = "", message = "", msgobj = null }) => {
        if (user == null || user.length === 0 || message == null || message.length === 0 || !message.includes('!') || msgobj == null || msgobj.length === 0) {          
          return;
        }

        const msgMap = {
          emotes: [],
          text: [],
        }

        msgobj.reduce((prev, curr) => {
          switch (curr.type) {
            case 'emote':
              prev.emotes.push(curr)
              break
            case 'text':
              prev.text.push(curr)
              break
            default:
              break
          }
          return prev;          
        }, msgMap)

        // no emote, just leave
        if (msgMap.emotes.length === 0) {
          return;
        }

        const validEmotes = msgMap.emotes.reduce((prev, curr) => {
          if (curr.name in cmds) {
            prev.push(curr.name)
          }
          return prev
        }, [])

        if (validEmotes.length === 0) {
          return
        }

        const firstEmote = validEmotes[0];
    
        let cueToPlay = null;

        const pickFromArray = cmds[firstEmote];
        if (pickFromArray == null || pickFromArray.length === 0){ 
          return
        }
        const hashedMsg = hashStr(message);
        const idx = mod(hashedMsg, pickFromArray.length);
        cueToPlay = pickFromArray[idx];
        

        if (cueToPlay == null || cueToPlay.length === 0) {
          return;
        }

        if (nodecg.findCue(cueToPlay)) {
          nodecg.playSound(cueToPlay);
          nodecg.sendMessage("played-cue", cueToPlay);
        }
      };

      NodeCG.waitForReplicants(audioEnabled)
        .then(() => {
          audioEnabled.on("change", (nextVal, prevVal) => {
            if (prevVal == null && nextVal != null) {
              nodecg.listenFor("ChatReceived", "twitch-listener", onChatReceived);
            } else if (prevVal != null && nextVal == null) {
              nodecg.unlisten("ChatReceived", "twitch-listener", onChatReceived);
            }
          });
        })
        .catch((e) => console.error("An error occurred setting up the chat listener."));
    </script>
  </body>
</html>
