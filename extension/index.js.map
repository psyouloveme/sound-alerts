{"mappings":"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","sources":["src/extension/NodeCGHandle.ts","src/types/SoundAlertReplicants.ts","src/types/SoundCommandEvents.ts","src/types/SoundCommandType.ts","src/extension/ChatListeners.ts","src/types/ReplicantEvents.ts","src/extension/EventListeners.ts","src/extension/index.ts"],"sourcesContent":["import { type NodeCG } from 'nodecg-types/types/server'\n\ninterface Handle<T> {\n  current: T | null\n}\n\nconst nodecgHandle: Handle<NodeCG> = {\n  current: null\n}\n\nexport default nodecgHandle\n","export enum SoundAlertReplicants {\n  soundCueConfig = 'soundCueConfig',\n  soundCuesEnabled = 'soundCuesEnabled',\n  soundCueList = 'soundCueList',\n  soundCueLog = 'soundCueLog',\n  soundCueTypes = 'soundCueTypes',\n  soundCueCommandIndex = 'soundCueCommandIndex',\n  nodeCGServerSoundCues = 'soundCues' // this is for the extension to get the defined cues\n}\n","export enum SoundCommandEvents {\n  playedSoundCue = 'playedCue',\n  playSoundCue = 'playSoundCue',\n  upsertSoundCommand = 'upsertSoundCommand',\n  deleteSoundCommand = 'deleteSoundCommand',\n  twitchChatReceived = 'ChatReceived',\n}\n","/**\n * Command type for the sound command configuration structure.\n * @see {@link SoundCommand} or {@link SoundCommandChangeMessage} for usages.\n */\nexport enum SoundCommandType {\n  /**\n     * Single commands expect only 1 mapped cue and play the first one\n     * that was added to the cue list.\n     */\n  single = 'single',\n  /**\n     * Random commands will select a cue at random every call.\n     */\n  random = 'random',\n  /**\n     * Ordered commands will play the mapped cues in order on each call.\n     */\n  ordered = 'ordered'\n};\n","import { SoundAlertReplicants } from '../types/SoundAlertReplicants'\nimport { type SoundCueNameList } from '../types/SoundCueNameList'\nimport { SoundCommandEvents } from '../types/SoundCommandEvents'\nimport { SoundCommandType } from '../types/SoundCommandType'\nimport nodecgHandle from './NodeCGHandle'\n\n// old method\n// function onChatReceived ({ user = '', message = '' }): void {\n//   if ((user.length === 0) || (message.length === 0) || !message.startsWith('!')) {\n//     return\n//   }\n\n//   const splitAlert = message.split(' ')[0]\n//   if ((splitAlert.length > 0) && (nodecg.findCue(splitAlert) != null)) {\n//     nodecg.playSound(splitAlert)\n//     void nodecg.sendMessage(SoundCommandEvents.playedSoundCue, splitAlert)\n//   }\n// };\n\nexport function twitchChatReceived ({ user = '', message = '' }): void {\n  if ((user.length === 0) || (message.length === 0)) {\n    return\n  }\n  if (nodecgHandle.current == null) {\n    throw Error('Cue command change failed: NodeCG handle is invalid.')\n  }\n  const nodecg = nodecgHandle.current\n\n  const soundCueMap = nodecg.Replicant<SoundCommandList>(SoundAlertReplicants.soundCueConfig)\n  if (soundCueMap.value === undefined) {\n    nodecg.log.error('Cue command change failed: Sound cue map is undefined.')\n    return\n  }\n\n  const splitAlert = message.split(' ')[0]\n  const idx = soundCueMap.value.findIndex((c) => c.commandName === splitAlert)\n  if (idx < 0) {\n    return\n  }\n  const cmd = soundCueMap.value[idx]\n  if (!cmd.enabled) {\n    nodecg.log.debug(`Cue command ${splitAlert} is disabled, not playing.`)\n  }\n  if (!cmd.allCuesAreValid) {\n    nodecg.log.warn(`Cue command ${splitAlert} has invalid cues, not playing.`)\n    return\n  }\n  if ((cmd.coolDownMs != null) && (cmd.lastUseTimestamp != null) && (Date.now() - cmd.lastUseTimestamp) < cmd.coolDownMs) {\n    nodecg.log.warn(`Cue command ${splitAlert} is still on cooldown, not playing.`)\n    return\n  }\n  if ((cmd.mappedCues == null) || cmd.mappedCues.length === 0) {\n    nodecg.log.warn(`Cue command ${splitAlert} has no mapped cues.`)\n    return\n  }\n\n  let cue: string | null = null\n  let orderedIndex = cmd.orderedMappingIndex ?? 0\n  if (cmd.mappedCues.length < orderedIndex) {\n    orderedIndex = 0\n  }\n  let nextOrderedIndex = null\n\n  switch (cmd.commandType) {\n    case SoundCommandType.single:\n      cue = cmd.mappedCues[0]\n      break\n    case SoundCommandType.ordered:\n      cue = cmd.mappedCues[orderedIndex]\n      nextOrderedIndex = orderedIndex + 1\n      break\n    case SoundCommandType.random:\n      cue = cmd.mappedCues[Math.floor(Math.random() * cmd.mappedCues.length)]\n      break\n    default:\n      nodecg.log.warn(`Cue command ${splitAlert} has an invalid type.`)\n      return\n  }\n\n  const knownSoundCues = nodecg.Replicant<SoundCueNameList>(SoundAlertReplicants.soundCueList)\n  if (soundCueMap.value === undefined) {\n    nodecg.log.error('Cue command change failed: Sound cue list is undefined.')\n    return\n  }\n\n  if ((cue.length === 0) || (knownSoundCues.value.find((c) => c === cue) == null)) {\n    nodecg.log.warn(`Cue command ${splitAlert} did not map to a known cue. Mapped cue was ${cue.length > 0 ? cue : '\"null\"'}.`)\n    return\n  }\n\n  nodecg.sendMessage(SoundCommandEvents.playSoundCue, cue)\n  soundCueMap.value[idx] = {\n    ...soundCueMap.value[idx],\n    lastUseTimestamp: Date.now(),\n    orderedMappingIndex: nextOrderedIndex,\n    commandUsageCount: soundCueMap.value[idx].commandUsageCount + 1\n  }\n}\n","enum ReplicantEvents {\n  change = 'change'\n}\n\nexport default ReplicantEvents\n","import nodecgHandle from './NodeCGHandle'\nimport { type ListenForCb } from 'nodecg-types/types/lib/nodecg-instance'\nimport { SoundAlertReplicants } from '../types/SoundAlertReplicants'\n\nexport function playedSoundCue (cueName: string, ack?: ListenForCb): void {\n  if (nodecgHandle.current == null) {\n    throw Error('Cue command delete failed: NodeCG handle is invalid.')\n  }\n  const nodecg = nodecgHandle.current\n  const audioAlertLog = nodecg.Replicant<AudioAlertLog>(SoundAlertReplicants.soundCueLog, {\n    defaultValue: {}\n  })\n\n  nodecg.log.info('played cue: %s', cueName)\n  if (cueName == null || cueName.length > 0) {\n    if (cueName in audioAlertLog.value) {\n      audioAlertLog.value[cueName] += 1\n    } else {\n      audioAlertLog.value[cueName] = 1\n    }\n    nodecg.log.info('cue %s is now at %s plays', cueName, audioAlertLog.value[cueName])\n  }\n\n  if ((ack != null) && !ack.handled) {\n    ack(null)\n  }\n}\n","import { type NodeCG } from 'nodecg-types/types/server'\nimport nodecgHandle from './NodeCGHandle'\nimport { twitchChatReceived } from './ChatListeners'\nimport { SoundAlertReplicants } from '../types/SoundAlertReplicants'\nimport { type SoundCueNameList } from '../types/SoundCueNameList'\nimport ReplicantEvents from '../types/ReplicantEvents'\nimport { playedSoundCue } from './EventListeners'\nimport { SoundCommandType } from '../types/SoundCommandType'\nimport { SoundCommandEvents } from '../types/SoundCommandEvents'\n\nenum BundleDeps {\n  twitchListener = 'twitch-listener'\n};\n\nfunction getDefaultCueMap (): SoundCommandList {\n  if (nodecgHandle.current == null) {\n    throw Error('Cue command mapping failed: NodeCG handle is invalid.')\n  }\n  const nodecg = nodecgHandle.current\n  const cuemap: SoundCommandList = []\n  const soundCues = nodecg.readReplicant<CueAssets>(SoundAlertReplicants.nodeCGServerSoundCues)\n  const cueIndex = nodecg.Replicant<number>(SoundAlertReplicants.soundCueCommandIndex)\n\n  if (soundCues != null && soundCues.length > 0) {\n    for (let c = 0; c < soundCues.length; c++) {\n      const cue = soundCues[c]\n      cuemap.push({\n        id: ++cueIndex.value,\n        commandName: cue.name.startsWith('!') ? cue.name : `!${cue.name}`,\n        enabled: false,\n        coolDownMs: null,\n        lastUseTimestamp: null,\n        allCuesAreValid: true,\n        mappedCues: [cue.name],\n        orderedMappingIndex: null,\n        commandType: SoundCommandType.single,\n        commandUsageCount: 0\n      })\n    }\n  }\n  return cuemap\n}\n\nmodule.exports = function (nodecg: NodeCG) {\n  nodecg.log.debug('Soundalerts bundle started.')\n  nodecgHandle.current = nodecg\n\n  // create replicants if they don't exist\n  nodecg.Replicant<number>(SoundAlertReplicants.soundCueCommandIndex, { defaultValue: 0 })\n  nodecg.Replicant<boolean>(SoundAlertReplicants.soundCuesEnabled, { defaultValue: false })\n  nodecg.Replicant<AudioAlertLog>(SoundAlertReplicants.soundCueLog, { defaultValue: {} })\n  nodecg.Replicant<SoundCommandType[]>(SoundAlertReplicants.soundCueTypes, {\n    defaultValue: [\n      SoundCommandType.ordered,\n      SoundCommandType.random,\n      SoundCommandType.single\n    ]\n  })\n\n  // set up sound cues if not intialized\n  const soundCueMap = nodecg.Replicant<SoundCommandList>(SoundAlertReplicants.soundCueConfig)\n  // if (!soundCueMap.value || soundCueMap.value.length === 0) {\n  soundCueMap.value = getDefaultCueMap()\n  // }\n\n  const knownSoundCues = nodecg.Replicant<SoundCueNameList>(SoundAlertReplicants.soundCueList, { defaultValue: [] })\n  // refresh list of known sound cues when the cue replicant changes\n  nodecg.Replicant<CueAssets>(SoundAlertReplicants.nodeCGServerSoundCues)\n    .on(ReplicantEvents.change, (newVal) => {\n      knownSoundCues.value = newVal.map((c) => c.name)\n    })\n\n  // refresh status of mapped cues when known cue list changes\n  knownSoundCues.on(ReplicantEvents.change, (newVal) => {\n    soundCueMap.value.forEach((c) => {\n      c.allCuesAreValid = c.mappedCues.every((mc) => newVal.includes(mc))\n    })\n  })\n\n  // bind event listeners\n  // nodecg.listenFor(SoundCommandEvents.upsertSoundCommand, upsertSoundCommand)\n  // nodecg.listenFor(SoundCommandEvents.deleteSoundCommand, deleteSoundCommand)\n  nodecg.listenFor(SoundCommandEvents.playedSoundCue, playedSoundCue)\n  nodecg.listenFor(SoundCommandEvents.twitchChatReceived, BundleDeps.twitchListener, twitchChatReceived)\n}\n"],"names":["$ae62765384d6524f$export$2e2bcd8739ae039","current","$bbe29ece3859b5d0$export$501f6df0ab3ca018","SoundAlertReplicants","$63071c7b6ed1cc77$export$f38747a4ce612b5d","SoundCommandEvents","$0c665931ece67ef6$export$6738b49e1226737f","SoundCommandType","$947b45423ba2c24d$export$273d292cccc8fdda","user","message","length","Error","nodecg","soundCueMap","Replicant","soundCueConfig","undefined","value","log","error","splitAlert","split","idx","findIndex","c","commandName","cmd","enabled","debug","allCuesAreValid","warn","coolDownMs","lastUseTimestamp","Date","now","mappedCues","cue","orderedIndex","orderedMappingIndex","nextOrderedIndex","commandType","single","ordered","random","Math","floor","knownSoundCues","soundCueList","find","sendMessage","playSoundCue","commandUsageCount","$f1d4f046f39eaf99$var$ReplicantEvents","$f1d4f046f39eaf99$export$2e2bcd8739ae039","$8ab8d7f250330d0f$export$2fff8fdbb4b9ea48","cueName","ack","audioAlertLog","soundCueLog","defaultValue","info","handled","$3c67f3a0adc69e00$var$BundleDeps","module","exports","soundCueCommandIndex","soundCuesEnabled","soundCueTypes","cuemap","soundCues","readReplicant","nodeCGServerSoundCues","cueIndex","push","id","name","startsWith","$3c67f3a0adc69e00$var$getDefaultCueMap","on","change","newVal","map","forEach","every","mc","includes","listenFor","playedSoundCue","twitchChatReceived","twitchListener"],"version":3,"file":"index.js.map","sourceRoot":"../"}