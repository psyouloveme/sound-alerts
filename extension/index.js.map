{"mappings":"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","sources":["src/extension/NodeCGHandle.ts","src/types/SoundAlertReplicants.d.ts","src/types/SoundCommandType.d.ts","src/extension/ConfigListeners.ts","src/extension/ChatListeners.ts","src/types/SoundCommandEvents.d.ts","src/types/ReplicantEvents.d.ts","src/extension/EventListeners.ts","src/extension/index.ts"],"sourcesContent":["import { NodeCG } from \"nodecg-types/types/server\";\n\ntype Handle<T> = {\n\tcurrent: T | null;\n};\n\nconst nodecgHandle : Handle<NodeCG> = {\n\tcurrent: null\n};\n\nexport default nodecgHandle;","export enum SoundAlertReplicants {\n    soundCueConfig = \"soundCueConfig\",\n    soundCuesEnabled = \"soundCuesEnabled\",\n    soundCueList = \"soundCueList\",\n    soundCueLog = \"soundCueLog\",\n    soundCueTypes = \"soundCueTypes\",\n    nodeCGServerSoundCues = \"soundCues\", // this is for the extension to get the defined cues\n}\n\nexport type SoundCueNameList = string[];\n","/**\n * Command type for the sound command configuration structure.\n * @see {@link SoundCommand} or {@link SoundCommandChangeMessage} for usages.\n */\nenum SoundCommandType {\n    /**\n     * Single commands expect only 1 mapped cue and play the first one\n     * that was added to the cue list.\n     */\n    single = \"single\",\n    /**\n     * Random commands will select a cue at random every call.\n     */\n    random = \"random\",\n    /**\n     * Ordered commands will play the mapped cues in order on each call.\n     */\n    ordered = \"ordered\"\n};\n\nexport default SoundCommandType","import { SoundAlertReplicants, SoundCueNameList } from \"../types/SoundAlertReplicants.d\";\nimport SoundCommandType from \"../types/SoundCommandType.d\";\nimport nodecgHandle from \"./NodeCGHandle\";\nimport { ListenForCb } from \"nodecg-types/types/lib/nodecg-instance\";\n\nexport function upsertSoundCommand(newCue: SoundCommandChangeMessage, ack? : ListenForCb) {\n\tif (!nodecgHandle.current) {\n\t\tthrow Error(\"Cue command change failed: NodeCG handle is invalid.\");\n\t}\n\tconst nodecg = nodecgHandle.current;\n\n\tconst soundCueMap = nodecg.Replicant<SoundCommandList>(SoundAlertReplicants.soundCueConfig);\n\tif (soundCueMap.value === undefined && ack && !ack.handled) {\n\t\tack(Error(`Cue command change failed: Sound cue map is undefined.`))\n\t\treturn;\n\t}\n\n\tconst knownSoundCues = nodecg.Replicant<SoundCueNameList>(SoundAlertReplicants.soundCueList);\n\tif (soundCueMap.value === undefined && ack && !ack.handled) {\n\t\tack(Error(`Cue command change failed: Sound cue list is undefined.`))\n\t\treturn;\n\t}\n\n\tif (!newCue.commandName && ack && !ack.handled) {\n\t\tack(Error(`Cue command change failed: No cue command name was provided.`));\n\t\treturn;\n\t}\n\tif ((!newCue.mappedCues || newCue.mappedCues.length === 0) && ack && !ack.handled) {\n\t\tack(Error(`Cue command change failed: No cues were mapped to command ${newCue.commandName}.`));\n\t\treturn;\n\t} \n\n\tnodecg.log.debug(\"changing cue command: %s\", newCue.commandName);\n\tlet idx = soundCueMap.value.findIndex((c) => c.commandName === newCue.commandName);\n\tif (idx < 0)  {\n\t\tsoundCueMap.value.push({\n\t\t\tcommandName: newCue.commandName,\n\t\t\tcoolDownMs: newCue.coolDownMs,\n\t\t\tcommandType: newCue.commandType,\n\t\t\tenabled: newCue.enabled,\n\t\t\torderedMappingIndex: newCue.commandType === SoundCommandType.ordered ? 0 : null,\n\t\t\tcommandUsageCount: 0,\n\t\t\tlastUseTimestamp: null,\n\t\t\tallCuesAreValid: newCue.mappedCues.every((mc) => knownSoundCues.value.includes(mc)),\n\t\t\tmappedCues: [ ...newCue.mappedCues, ]\n\t\t});\n\t} else {\n\t\tlet oldCue = soundCueMap.value[idx];\n\t\tlet nextCue = {\n\t\t\t...oldCue,\n\t\t\tcoolDownMs: newCue.coolDownMs,\n\t\t\torderedMappingIndex: newCue.commandType === SoundCommandType.ordered ? 0 : null,\n\t\t\tcommandType: newCue.commandType,\n\t\t\tenabled: newCue.enabled,\n\t\t\tallCuesAreValid: newCue.mappedCues.every((mc) => knownSoundCues.value.includes(mc)),\n\t\t\tmappedCues: [ ...newCue.mappedCues, ]\n\t\t};\n\t\tsoundCueMap.value[idx] = nextCue;\n\t}\n}\n\nexport function deleteSoundCommand(commandName: string, ack?: ListenForCb) {\n\tif (!nodecgHandle.current) {\n\t\tthrow Error(\"Cue command delete failed: NodeCG handle is invalid.\");\n\t}\n\tconst nodecg = nodecgHandle.current;\n\n\tconst soundCueMap = nodecg.Replicant<SoundCommandList>(SoundAlertReplicants.soundCueConfig);\n\tif (soundCueMap.value === undefined && ack && !ack.handled) {\n\t\tack(Error(`Cue command delete failed: Sound cue map is undefined.`))\n\t\treturn;\n\t}\n\n\tnodecg.log.debug(\"deleting cue command: %s\", commandName);\n\tif (!commandName && ack && !ack.handled) {\n\t\tack(Error(`Cue command delete failed: No cue command name was provided.`));\n\t\treturn;\n\t}\n\t\n\tlet idx = soundCueMap.value.findIndex((c) => c.commandName === commandName);\n\tif (idx < 0 && ack && !ack.handled) {\n\t\tack(Error(`Cue command delete failed: No cue command ${commandName} was found.`));\n\t\treturn;\n\t}\n\n\tsoundCueMap.value = soundCueMap.value.splice(idx, 1);\n}\n\n\n","import nodecgHandle from \"./NodeCGHandle\";\n\n// old method\nfunction onChatReceived({ user = \"\", message = \"\" }) {\n\tif (!user || !message || !message.startsWith(\"!\")) {\n\t  return;\n\t}\n\n\tconst splitAlert = message.split(\" \")[0];\n\tif (splitAlert && nodecg.findCue(splitAlert)) {\n\t  nodecg.playSound(splitAlert);\n\t  nodecg.sendMessage(SoundCommandEvents.playedSoundCue, splitAlert);\n\t}\n};\n\nexport function twitchChatReceived ({ user = \"\", message = \"\" }) {\n\tif (!user || !message) {\n\t\treturn;\n\t}\n\tif (!nodecgHandle.current) {\n\t\tthrow Error(\"Cue command change failed: NodeCG handle is invalid.\");\n\t}\n\tconst nodecg = nodecgHandle.current;\n\n\tconst soundCueMap = nodecg.Replicant<SoundCommandList>(SoundAlertReplicants.soundCueConfig);\n\tif (soundCueMap.value === undefined) {\n\t\tnodecg.log.error(`Cue command change failed: Sound cue map is undefined.`);\n\t\treturn;\n\t}\n\n\tconst splitAlert = message.split(\" \")[0];\n\tlet idx = soundCueMap.value.findIndex((c) => c.commandName === splitAlert);\n\tif (idx < 0) {\n\t\treturn;\n\t}\n\tconst cmd = soundCueMap.value[idx];\n\tif (!cmd.enabled) {\n\t\tnodecg.log.debug(`Cue command ${splitAlert} is disabled, not playing.`);\n\t}\n\tif (!cmd.allCuesAreValid) {\n\t\tnodecg.log.warn(`Cue command ${splitAlert} has invalid cues, not playing.`);\n\t\treturn;\n\t}\n\tif (cmd.coolDownMs && cmd.lastUseTimestamp && (Date.now() - cmd.lastUseTimestamp) < cmd.coolDownMs) {\n\t\tnodecg.log.warn(`Cue command ${splitAlert} is still on cooldown, not playing.`);\n\t\treturn;\n\t}\n\tif (!cmd.mappedCues || cmd.mappedCues.length === 0) {\n\t\tnodecg.log.warn(`Cue command ${splitAlert} has no mapped cues.`);\n\t\treturn;\n\t}\n\n\tlet cue : string | null = null;\n\tlet orderedIndex = cmd.orderedMappingIndex || 0;\n\tif (cmd.mappedCues.length < orderedIndex) {\n\t\torderedIndex = 0;\n\t}\n\tlet nextOrderedIndex = null;\n\t\n\tswitch (cmd.commandType) {\n\t\tcase SoundCommandType.single:\n\t\t\tcue = cmd.mappedCues[0];\n\t\t\tbreak;\n\t\tcase SoundCommandType.ordered:\n\t\t\tcue = cmd.mappedCues[orderedIndex];\n\t\t\tnextOrderedIndex = orderedIndex + 1;\n\t\t\tbreak;\n\t\tcase SoundCommandType.random:\n\t\t\tcue = cmd.mappedCues[Math.floor(Math.random() * cmd.mappedCues.length)];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnodecg.log.warn(`Cue command ${splitAlert} has an invalid type.`);\n\t\t\treturn;\n\t}\n\n\tconst knownSoundCues = nodecg.Replicant<SoundCueNameList>(SoundAlertReplicants.soundCueList);\n\tif (soundCueMap.value === undefined ) {\n\t\tnodecg.log.error(`Cue command change failed: Sound cue list is undefined.`);\n\t\treturn;\n\t}\n\n\tif (!cue || !knownSoundCues.value.find((c) => c === cue)) {\n\t\tnodecg.log.warn(`Cue command ${splitAlert} did not map to a known cue. Mapped cue was ${cue || '\"null\"'}.`);\n\t\treturn;\n\t}\n\n\tnodecg.sendMessage(SoundCommandEvents.playSoundCue, cue);\n\tsoundCueMap.value[idx] = {\n\t\t...soundCueMap.value[idx],\n\t\tlastUseTimestamp: Date.now(),\n\t\torderedMappingIndex: nextOrderedIndex,\n\t\tcommandUsageCount: soundCueMap.value[idx].commandUsageCount + 1\n\t}\n}","enum SoundCommandEvents {\n    playedSoundCue = \"playedCue\",\n    playSoundCue = \"playSoundCue\",\n    upsertSoundCommand = \"upsertSoundCommand\",\n    deleteSoundCommand = \"deleteSoundCommand\",\n    twitchChatReceived = \"ChatReceived\",\n}\n\nexport default SoundCommandEvents","enum ReplicantEvents {\n    change = \"change\"\n}\n\nexport default ReplicantEvents","import nodecgHandle from \"./NodeCGHandle\";\nimport { ListenForCb } from \"nodecg-types/types/lib/nodecg-instance\";\nimport { SoundAlertReplicants } from \"../types/SoundAlertReplicants.d\";\n\nexport function playedSoundCue(cueName: string, ack?: ListenForCb) {\n\tif (!nodecgHandle.current) {\n\t\tthrow Error(\"Cue command delete failed: NodeCG handle is invalid.\");\n\t}\n\tconst nodecg = nodecgHandle.current;\n\tconst audioAlertLog = nodecg.Replicant<AudioAlertLog>(SoundAlertReplicants.soundCueLog, {\n\t\tdefaultValue: {}\n\t});\n\t\n\tnodecg.log.info(\"played cue: %s\", cueName);\n\tif (cueName) {\n\t\tif (cueName in audioAlertLog.value) {\n\t\t\taudioAlertLog.value[cueName] += 1;\n\t\t} else {\n\t\t\taudioAlertLog.value[cueName] = 1;\n\t\t}\n\t\tnodecg.log.info(\"cue %s is now at %s plays\", cueName, audioAlertLog.value[cueName]);\n\t}\n\n\tif (ack && !ack.handled) {\n\t\tack(null);\n\t}\n}","import { NodeCG } from \"nodecg-types/types/server\";\nimport nodecgHandle from \"./NodeCGHandle\";\nimport { deleteSoundCommand, upsertSoundCommand } from \"./ConfigListeners\";\nimport { twitchChatReceived } from \"./ChatListeners\";\nimport { SoundAlertReplicants, SoundCueNameList } from \"../types/SoundAlertReplicants.d\";\nimport SoundCommandType from \"../types/SoundCommandType.d\";\nimport SoundCommandEvents from \"../types/SoundCommandEvents.d\";\nimport ReplicantEvents from \"../types/ReplicantEvents.d\";\nimport { playedSoundCue } from \"./EventListeners\";\n\nenum BundleDeps {\n\ttwitchListener = \"twitch-listener\"\n};\n\nfunction getDefaultCueMap() {\n\tif (!nodecgHandle.current) {\n\t\tthrow Error(\"Cue command change failed: NodeCG handle is invalid.\");\n\t}\n\tconst nodecg = nodecgHandle.current;\n\tconst cuemap : SoundCommandList = [];\n\tconst soundCues = nodecg.readReplicant<CueAssets>(SoundAlertReplicants.nodeCGServerSoundCues);\n\tif (soundCues && soundCues.length > 0) {\n\t\tfor (let c = 0; c < soundCues.length; c++) {\n\t\t\tlet cue = soundCues[c];\n\t\t\tcuemap.push({\n\t\t\t\tcommandName: cue.name.startsWith(\"!\") ? cue.name : `!${cue.name}`,\n\t\t\t\tenabled: false,\n\t\t\t\tcoolDownMs: null,\n\t\t\t\tlastUseTimestamp: null,\n\t\t\t\tallCuesAreValid: true,\n\t\t\t\tmappedCues: [cue.name],\n\t\t\t\torderedMappingIndex: null,\n\t\t\t\tcommandType: SoundCommandType.single,\n\t\t\t\tcommandUsageCount: 0\n\t\t\t})\n\t\t}\n\t}\n\treturn cuemap;\n}\n\nfunction initCueTypes() {\n\treturn [ SoundCommandType.ordered, SoundCommandType.random, SoundCommandType.single ];\n}\n\nmodule.exports = function (nodecg : NodeCG) {\n\tnodecg.log.debug('Soundalerts bundle started.');\n\tnodecgHandle.current = nodecg;\n\n\t// create replicants if they don't exist\n\tnodecg.Replicant<boolean>(SoundAlertReplicants.soundCuesEnabled, { defaultValue: false });\n\tnodecg.Replicant<AudioAlertLog>(SoundAlertReplicants.soundCueLog, { defaultValue: {} });\n\t\n\tconst soundCueTypes = nodecg.Replicant<string[]>(SoundAlertReplicants.soundCueTypes);\n\tif (!soundCueTypes.value) {\n\t\tsoundCueTypes.value = initCueTypes();\n\t}\n\n\t// set up sound cues if not intialized\n\tconst soundCueMap = nodecg.Replicant<SoundCommandList>(SoundAlertReplicants.soundCueConfig);\n\t// if (!soundCueMap.value || soundCueMap.value.length === 0) {\n\t\tsoundCueMap.value = getDefaultCueMap();\n\t// }\n\n\t// refresh list of known sound cues when the cue replicant changes\n\tconst knownSoundCues = nodecg.Replicant<SoundCueNameList>(SoundAlertReplicants.soundCueList, { defaultValue: [] });\n\t\n\tnodecg.Replicant<CueAssets>(SoundAlertReplicants.nodeCGServerSoundCues)\n\t\t.on(ReplicantEvents.change, (newVal) => {\n\t\t\tknownSoundCues.value = newVal.map((c) => c.name);;\n\t\t});\n\n\t// refresh status of mapped cues when known cue list changes\n\tknownSoundCues.on(ReplicantEvents.change, (newVal) => {\n\t\tsoundCueMap.value.forEach((c) => {\n\t\t\tc.allCuesAreValid = c.mappedCues.every((mc) => newVal.includes(mc))\n\t\t})\n\t});\n\n\t// bind event listeners\n\tnodecg.listenFor(SoundCommandEvents.upsertSoundCommand, upsertSoundCommand);\n\tnodecg.listenFor(SoundCommandEvents.deleteSoundCommand, deleteSoundCommand);\n\tnodecg.listenFor(SoundCommandEvents.playedSoundCue, playedSoundCue);\n\tnodecg.listenFor(SoundCommandEvents.twitchChatReceived, BundleDeps.twitchListener, twitchChatReceived);\n};\n"],"names":["$ae62765384d6524f$export$2e2bcd8739ae039","current","$6a4f54c29992c952$export$501f6df0ab3ca018","$5318210607127921$var$SoundCommandType","SoundAlertReplicants","SoundCommandType","$5318210607127921$export$2e2bcd8739ae039","$592636faf8373518$export$d634ad72e4c9b5b4","newCue","ack","Error","nodecg","soundCueMap","Replicant","soundCueConfig","undefined","value","handled","knownSoundCues","soundCueList","commandName","mappedCues","length","log","debug","idx","findIndex","c","push","coolDownMs","commandType","enabled","orderedMappingIndex","ordered","commandUsageCount","lastUseTimestamp","allCuesAreValid","every","mc","includes","nextCue","$592636faf8373518$export$1f58207e19c506da","splice","$947b45423ba2c24d$export$273d292cccc8fdda","user","message","nodecg1","error","splitAlert","split","cmd","warn","Date","now","cue","orderedIndex","nextOrderedIndex","single","random","Math","floor","find","sendMessage","SoundCommandEvents","playSoundCue","$85d48165ec2a92fb$var$SoundCommandEvents","$85d48165ec2a92fb$export$2e2bcd8739ae039","$2f1e3aa387e81bf8$var$ReplicantEvents","$2f1e3aa387e81bf8$export$2e2bcd8739ae039","$8ab8d7f250330d0f$export$2fff8fdbb4b9ea48","cueName","audioAlertLog","soundCueLog","defaultValue","info","$3c67f3a0adc69e00$var$BundleDeps","module","exports","soundCuesEnabled","soundCueTypes","cuemap","soundCues","readReplicant","nodeCGServerSoundCues","name","startsWith","$3c67f3a0adc69e00$var$getDefaultCueMap","on","change","newVal","map","forEach","listenFor","upsertSoundCommand","deleteSoundCommand","playedSoundCue","twitchChatReceived","twitchListener"],"version":3,"file":"index.js.map","sourceRoot":"../"}